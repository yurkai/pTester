---
title: "Анализ группы ВК: часть 3, моделирование"
author: 'Юрий Исаков'
date: 'Май 2016'
output: 
  html_document: 
    fig_caption: yes
    keep_md: yes
    toc: yes
---

***

Отчет в трех частях о работе с данными группы ВКонтакте с помощью языка R. [Первая часть](http://rpubs.com/yurkai/runvrn_part1) описывает получение и обработку данных, [вторая](http://rpubs.com/yurkai/runvrn_part2) -- их визуализацию, а [третья часть](http://rpubs.com/yurkai/runvrn_part3) посвящена моделированию. В качестве анализируемой группы выступает [беговое сообщество Воронежа](https://vk.com/runningvrn).

***

В третьей части применим методы машинного обучения, чтобы получить больше информации из данных, полученных в части 1.

### 1. Начало

Загрузим необходимые библиотеки и данные из первой части. 

```{r p3_intro, message=FALSE}
Sys.setlocale('LC_ALL','utf-8') # если нет проблем с кодировкой, отключите эту строчку
library(dplyr)
library(ggplot2)
library(car)
library(lmtest)
library(factoextra)
library(clValid)
load("runningvrn.RData")
```

Преобразуем данные для моделей, получим: активность каждого пользователя за последние полгода (чтобы история не мешала) и активность всех пользователей на стене. 

Для первой таблички напишем функцию, которая для каждого учатника из датафрейма `members` возвращает его активности на основе датафрейма `posts` -- посты, лайки, комментарии, лайки к другим комментариям и суммарное количество действий между датами `date_lo` и `date_hi` (могут быть пропущены, тогда будут включены самые ранние или самые поздние активности соответственно).

Для второй таблички посчитаем количество репостов, лайков, комментариев, лайков к комментариям и записей на стене за каждый месяц.

```{r p3_get_data}
# Возвращает активность пользователей из members на основании posts
# считаем, что вся активность к посту была в день его написания ;)
members_activity <- function(members, posts_all, date_lo=NULL, date_hi=NULL){
    # датафрейм с активностью пользователей
    df <- data.frame(uid = members$uid)
    # округляем даты, чтобы не зависеть от времени поста
    posts_all$dat <- round(posts_all$date, units = 'days')
    if (is.null(date_lo)) date_lo <- min(posts_all$date)
    if (is.null(date_hi)) date_hi <- max(posts_all$date)
    posts <- subset(posts_all, date >= date_lo & date <= date_hi)
    # считаем за период кто и сколько раз:
    # писал посты на стену (участники/админы)
    act_posters <- c(posts$author, posts$whodidthis)
    # лайкал посты
    act_likers <- unlist(posts$likers)
    # комментировал посты
    act_commenters <- unlist(posts$commenters)
    # лайкал комментарии
    act_comments_likers <- unlist(posts$comments_likers)
    
    # заполняем активности для каждого пользователя
    for (i in 1:dim(df)[1]) {
        # имя одной строкой
        df$full_name[i] <- paste(members$first_name[i],
                                 members$last_name[i])
        # считаем активность за период
        df$posts[i] <- sum(act_posters == df$uid[i], na.rm = TRUE)
        df$likes[i] <- sum(act_likers == df$uid[i])
        df$comments[i] <- sum(act_commenters == df$uid[i])
        df$comments_likes[i] <- sum(act_comments_likers == df$uid[i])
        df$all[i] = sum(df$posts[i], df$likes[i], df$comments[i],
                        df$comments_likes[i])
    }
    
    df
}

# получим данные об активности каждого пользователя за последние полгода
act_hy <- members_activity(members, posts, 
                          as.POSIXct('2015-10-01', origin="1970-01-01", 
                                     tz = 'Europe/Moscow'))

# соберем активности пользователей на стене за все время
month_activity <- posts %>% 
    mutate(period = as.Date(cut(date, breaks='month')),
           comments_likes = sapply(comments_likers, 
                                   function(p) length(unlist(p)))) %>%
    group_by(period) %>% 
    summarise(likes=sum(likes), comments=sum(comments), reposts=sum(reposts), 
              comments_likes=sum(comments_likes), n=n()) %>%
    as.data.frame()
```


### 2. Активность пользователей на стене

Создатель клуба хотел бы увеличить число репостов, чтоб увеличить аудиторию. Построим линейную регрессию репостов от остальных активностей.

```{r p3_month}
# посмотрим на данные
head(month_activity)
# и построим линейную модель
fit <- lm(reposts~likes+comments+comments_likes, data = month_activity)
summary(fit)
```

Неожиданно, скорректированный коэффициент детерминации оказался высоким, `R.adj=0.87`, а регрессоры статистически значимыми.

И пусть данных (по месяцам) мало, проверим их на мультиколлинеарность, гетероскедастичность, отстутствие объясняющих переменных и автокорреляцию:

* коэффициенты вздутия дисперсии оказались не высоки -- меньше 10, общепринятого значения, поэтому считаем, что мультиколлинеарность не присутствует (что неудивительно, регрессоры-то статистически значимы!);

* тест на гетероскедастичность (Бройша-Пагана): остатки в модели плохо предсказываются регрессорами, поэтому гипотезу о гетероскедастичности отвергаем;

* тест на автокорреляцию (Бройша-Годфри): данные представляют собой временной ряд, но недостаточно данных, чтобы отвергнуть гипотезу об отсутствии автокорреляции;

* тест на наличие пропущенных регрессоров (Рамси): гипотеза о линейной зависимости от регрессоров не может быть отвергнута, нелинейные члены не нужны.

```{r p3_tests}
# коэффициенты вздутия дисперсии
# меньше 10, мультиколлинеарность не присутствует
vif(fit)
# тест на гетероскедастичность
# недостаточно данных, чтобы отвергнуть гипотезу о гомоскедастичности
bptest(fit)
# тест на автокорреляцию
# гипотезу об отсутствии автокорреляции второго порядка не отвергаем
bgtest(fit, order=2)
# тест на отсутствие объясняющих переменных
# p-value велико, нет необходимости добавлять нелинейные члены
resettest(fit)
```

В этой модели все прекрасно: зависимая переменная отлично объясняется регрессорами, они статистически значимы, сама регрессия прошла тесты на отстутствие гетероскедастичности, мультиколлинеарности, автокорреляции и пропущенных переменных. И если бы такая связь между количеством репостов и лайками, комментариями, лайками к комментариями означала бы причинноость, можно было бы получить очевидное руководтство к действию для распространения новостей группы! Не будем относиться к этому серьезно, раскрасить в голубые и розовые тона оказалось очень легко (например, если разбить данные по неделям, мы получим иной результат).

### 3. Кластерный анализ участников группы

Попробуем разбить пользователей на группы в зависимости от их активностей: посты на стене, комментарии к ним и лайки к постам и комментариям. 

Отобразим пользователей в пространстве первых двух главных компонент (они объясняют 94% дисперсии), также отображаются вектора исходных переменных. Первое, что бросается в глаза -- участники `1` и `189`, которые съедают весь масштаб отображения. Еще можно заметить, что большая часть членов группы не проявляла никакой активности. Таким образом, получены первые две группы -- администраторы сообщества (вывод можно сделать не зная факта напрямую), один из которых автор, вторая -- участники, выводы о которых мы не можем сделать кроме того, что они никак себя не проявляют.

```{r p3_pca}
pca <- prcomp(act_hy[, 3:6], scale=TRUE)
fviz_pca_biplot(pca) + theme_bw() + labs(title ="Участники сообщества в координатах ГК", x = "ГК1", y = "ГК2")
# Большая часть участников никак не проявляла активности
# (суммарное число всех активностей и количество участников под ней)
table(act_hy$all)[1:5]
```

Введем новые признаки `clicker` и `reader`. Первый отвечает за долю односложных действий (пользователь кликнул лайк к посту или комментарию), а с помощью второго оценим насколько пользователю интересно читать обсуждения к посту (доля комментариев и лайков к ним по отношению к общему количеству действий). Отсеем пользователей, для которых мы уже определили классы и оценим на сколько кластеров можно разбить временный датафрейм (также используя два новых признака):

```{r p3_clustering, message=FALSE}
# вводим признак класса пользователя
act_hy$cls <- 0
# администраторы -- класс 6
act_hy$cls[c(1, 189)] <- 6
# неактивные участники (7 и меньше действий) -- класс 1
act_hy$cls[act_hy$all <= 7] <- 1

# добавим признаки clicker и reader 
act_hy = mutate(act_hy, clicker = (likes+comments_likes)/(all+1e-9),
                reader = (comments+comments_likes)/(all+1e-9))

# можно сделать имена строк именами участников, что наглядно
# но здесь сохраним им анонимность
# rownames(act_hy) <- make.names(act_hy$full_name, unique=TRUE)

# поместим неразмеченных участников во временный датафрейм
cols = c('likes',  'comments', 'reader', 'clicker',
         'comments_likes', 'posts')
act_temp = subset(act_hy, cls==0)[cols]

# оптимальное количество кластеров в зависимости от метрики
intern <- clValid(scale(act_temp), nClust = 2:8, 
                  clMethods = c("hierarchical","kmeans","pam"),
                  validation = "internal",method='ward')
summary(intern)
```

В зависимости от метрики временный датафрейм предложено разделить на 3 (на основании значений силуэта) или на 6 кластеров (используя индекс Данна). Значения метрик приведены для алгоритмов k-средних, k-медиан и иерархической кластеризации. 

После моделирования вяснилось, что в 3 кластера попадают очень разные участники, 6 кластеров оказалось много, т.к. половина из них представлена очень малым количество участников, наиболее наглядные визуализации силуэтов получаются для 5 кластеров, но оптимальным вариантом представляется делить на 4 группы. Именно для 4 кластеров результаты наиболее интерпретируемы. Воспользуемся иерархической кластеризацией: построим дендрограмму и отобразим участников группы в координатах двух главных компонент.

```{r p3_hclust}
# иерархическая кластеризация
res.hc <- hclust(dist(scale(act_temp), method = "euclidean"), 
                 method = "ward.D2" )
grp <- cutree(res.hc, k = 4)
# строим дендрограмму
par(mar=c(7,4,4,2))
plot(res.hc, cex = 0.6, main='Дендрограмма участников', 
     ylab='Количество', xlab='Участники', hang = -1, sub = "")
rect.hclust(res.hc, k = 4, border = 2:5)
# отображаем кластеры в координатах главных компонент
pca = prcomp(act_temp, scale = TRUE)
fviz_pca_biplot(pca, habillage = grp, addEllipses=TRUE, ellipse.level=0.75) + theme_bw() + labs(title ="Участники сообщества в координатах ГК", x = "ГК1", y = "ГК2")
```

Полученный точечный график можно интерпретировать следующим образом:

1) участники первого кластера, отображены точками, отличаются низкой активностью (в один клик), можно предположить, что эти пользователи не заходят в группу, а читают новости из ленты;

2) участники второго кластера, отображены треугольниками, отличаются низкой активностью, но она более разнообразная, здесь можно предположить, что эти участники нечасто пользуются социальной сетью, но они в отличие от первого кластера заходят в группу и смотрят как новости, так и посты участников;

3) участникам третьего кластера, отображены квадратиками, интересны обсуждения, они активно комментируют посты и пишут их сами, вектора `posts`, `comments` и `reader` направлены в сторону облака как раз этого кластера;

4) участники четвертого кластера, отображены крестиками, самые активные члены сообщества, они много общаются в группе, большая часть их активности приходится на лайки, как правило это знакомые между собой люди.

Теперь можно присвоить классы всем членам группы. И чем выше класс участника, тем активнее он проявляет себя в сообществе ВК. Выведем количество участников в каждом классе. Результат вполне ожидаемый, подавляющее большинство участников лишь числятся, как и в любых других сообществах.

```{r p3_table}
act_hy[rownames(act_temp), 'cls'] = grp + 1
table(act_hy$cls)
```


### 4. Заключение

Это небольшое исследование, пожалуй, нельзя считать объективным, потому как автор сам активный участник клуба, однако, неверно то, что данные, модели и графики подгонялись под ответ. Главной целью было выявление активных участников, которые регулярно посещают встречи клуба (пробежки, события и т.д.), что, строго говоря, не удалось. Так, встречи посещают участники из всех кластеров (например, много из первого, самого неактивного). А в кластерах 3 и 4, есть по одному участнику, кого мы не знаем лично (и ни разу не видели). Объяснить это можно довольно просто: основное общение происходит на встречах клуба, а его участники сами по себе очень разные, по сути он "офлайновый". А в сообществе представлен лишь определенный срез участников.

Тем не менее, соотнося полученные результаты с действительным положением вещей можно признать их вполне удовлетворительными. Были определены основные постмейкеры (в нашем случае администраторы), "писатели"", которые ведут больше всего обсуждений, "читатели"", которые, получают информацию о встречах из ленты новостей, а также группы участников заходящих время от времени и самых активных пользователей, которые ведут общение и в сети, и на встречах.

Если бы потребовалось взаимодействовать с участниками другого, неизвестного сообщества, то логично начать с описанных шагов, а также использовать более очевидные приемы (например, анализ меток на фотографиях).









